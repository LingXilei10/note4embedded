[[ARM 汇编\]进阶篇—存储访问指令—2.3.3 栈操作指令 - 博客0214 - 博客园](https://www.cnblogs.com/yaoqian/p/17486667.html)

栈是一种特殊的数据结构，其特点是**后进先出**（LIFO，Last In First Out）。在 ARM 汇编中，栈通常用于**保存函数调用时的寄存器状态、局部变量和返回地址等**。本节将详细介绍 ARM 汇编中的栈操作指令，并通过实例帮助你更好地理解和掌握这些指令。

### 推入栈（PUSH）

PUSH 指令用于将一个或多个寄存器的值推入栈中。基本语法如下：

```armasm
PUSH {reglist}
```

其中，**reglist 是要推入栈的寄存器列表。**

示例：

```armasm
PUSH {R0-R3} ; 将寄存器 R0-R3 的值推入栈中
```

在这个示例中，PUSH 指令将寄存器 R0-R3 的值推入栈中。注意，ARM 汇编中的**栈默认使用降序（Full Descending）模式**，即**栈顶指针指向栈的最高地址**，每次入栈操作时，**栈顶指针向低地址方向移动**。**栈顶指针通常使用 R13（也称为 SP，Stack Pointer）寄存器**。

### 弹出栈（POP）

POP 指令用于从栈中弹出一个或多个寄存器的值。基本语法如下：

```armasm
POP {reglist}
```

其中，reglist 是要从栈中弹出的寄存器列表。

示例：

```armasm
POP {R0-R3} ; 从栈中弹出值到寄存器 R0-R3
```

在这个示例中，POP 指令从栈中弹出值到寄存器 R0-R3。每次出栈操作时，**栈顶指针向高地址方向移动**。

以下是一个简单的示例，演示如何使用 PUSH 和 POP 指令保存和恢复寄存器状态：

```armasm
; 假设在调用一个函数前，需要保存 R0-R3 寄存器的值

PUSH {R0-R3} ; 将寄存器 R0-R3 的值推入栈中

; 调用函数
BL some_function

; 在函数返回后，恢复 R0-R3 寄存器的值
POP {R0-R3}
```

在这个示例中，我们首先使用 PUSH 指令将寄存器 R0-R3 的值保存到栈中，然后调用一个函数。在函数返回后，我们使用 POP 指令恢复 R0-R3 寄存器的值。这样，我们可以确保**在调用函数前后，寄存器的值不会被修改**。 

**BL指令记录返回地址（下一条指令的地址）到 R14(LR)里** 

**R13(SP)是堆栈指针**

在实际编程中，你可能需要根据具体需求使用 PUSH 和 POP 指令保存和恢复寄存器状态。通过多加练习和实践，你将更加熟练地掌握这些指令的使用。

现在让我们再看一个稍微复杂一点的例子，演示如何使用栈保存函数调用时的局部变量和返回地址：

假设我们有一个名为 `sum` 的函数，该函数计算两个整数的和。我们将使用 R0 和 R1 寄存器传递参数，将结果存储在 R0 寄存器中。在 `sum` 函数内部，我们将使用 R4 作为局部变量。

```armasm
; 调用 sum 函数的代码

MOV R0, #5  ; 第一个参数：5
MOV R1, #3  ; 第二个参数：3

BL sum  ; 调用 sum 函数

; 此时 R0寄存器中存储着两个数的和

; sum 函数的实现
sum:
; 保存寄存器状态
PUSH {R0-R3, R4, LR} ; 保存 R0-R3, R4 寄存器和返回地址（Link Register，LR）

; 计算两个数的和
MOV R4, R0 ; 将 R0 的值（第一个参数）复制到 R4 寄存器
ADD R0, R4, R1 ; 将 R4 和 R1 的值相加，并将结果存储在 R0 寄存器中

; 恢复寄存器状态
POP {R0-R3, R4, LR} ; 从栈中弹出值到 R0-R3, R4 寄存器和返回地址（Link Register，LR）

; 返回
BX LR ; 使用 BX 指令跳转到 LR 寄存器存储的返回地址
```

在这个例子中，我们首先使用 PUSH 指令保存寄存器 R0-R3、R4 和返回地址（Link Register，LR）。然后我们计算两个数的和，并将结果存储在 R0 寄存器中。最后，我们使用 POP 指令恢复寄存器状态，并使用 BX 指令跳转到 LR 寄存器存储的返回地址。

通过这个示例，你应该能更好地理解如何使用栈操作指令保存和恢复寄存器状态、局部变量和返回地址。在实际编程中，你可能需要根据具体需求使用这些指令。通过多加练习和实践，你将更加熟练地掌握这些指令的使用。