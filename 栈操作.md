栈（Stack）和 CPU 内存之间的关系主要体现在内存管理和函数调用的过程。这两者的结合使得程序能够有效地执行和管理数据。下面是更详细的解释：

### 1. 栈的概念

栈是一种特殊的内存结构，它遵循**后进先出（LIFO）**的原则。主要用于**存储局部变量**、**函数参数以及函数调用的返回地址**。栈在程序执行时动态管理内存，在很多编程语言中都是自动管理的。

### 2. 栈在 CPU 内存中的作用

- **函数调用管理**：
  当一个函数被调用时，CPU 把该函数中的局部变量和参数的值压入栈中，以便后续访问。函数返回时，这些信息会从栈中弹出。
  
- **上下文切换**：
  栈也用于存储执行上下文，例如在多线程环境中，各个线程都有自己的栈，以保持其执行状态和局部变量独立。

### 3. 栈和堆的区别

在内存管理中，栈和堆是两种不同的分配方式：

- **栈**：
  - 管理简单，系统自动分配和释放内存。
  - 速度较快，因为内存管理通过指针的位移（push/pop）实现。
  - 大小一般受到限制，通常较小。

- **堆**：
  - 由程序员手动管理（使用 `new` 或 `malloc` 等）。
  - 速度相对较慢，因为涉及到分配和释放的管理。
  - 大小可以更大，适合动态分配内存。

### 4. CPU 和内存的关系

- **CPU 的工作**：
  CPU 从内存中（包括栈和堆）读取数据并执行指令。栈和堆的内容在需要时被载入 CPU 寄存器进行处理。
- **内存层次结构**：
  CPU 内存层次结构决定了数据访问的速度，栈通常比堆更快，因为栈的内存访问局部性好并且管理简单。

### 5. 总结

栈是 CPU 内存中的一部分，它用于管理函数调用和局部变量。通过栈，CPU 能够高效地管理执行流程和数据，因此在编程语言中，理解栈的特性对有效使用资源和调试程序非常重要。





[[ARM 汇编\]进阶篇—存储访问指令—2.3.3 栈操作指令 - 博客0214 - 博客园](https://www.cnblogs.com/yaoqian/p/17486667.html)

栈是一种特殊的数据结构，其特点是**后进先出**（LIFO，Last In First Out）。在 ARM 汇编中，栈通常用于**保存函数调用时的寄存器状态、局部变量和返回地址等**。本节将详细介绍 ARM 汇编中的栈操作指令，并通过实例帮助你更好地理解和掌握这些指令。

### 推入栈（PUSH）

PUSH 指令用于将一个或多个寄存器的值推入栈中。基本语法如下：

```armasm
PUSH {reglist}
```

其中，**reglist 是要推入栈的寄存器列表。**

示例：

```armasm
PUSH {R0-R3} ; 将寄存器 R0-R3 的值推入栈中
```

在这个示例中，PUSH 指令将寄存器 R0-R3 的值推入栈中。注意，ARM 汇编中的**栈默认使用降序（Full Descending）模式**，即**栈顶指针指向栈的最高地址**，每次入栈操作时，**栈顶指针向低地址方向移动**。**栈顶指针通常使用 R13（也称为 SP，Stack Pointer）寄存器**。

### 弹出栈（POP）

POP 指令用于从栈中弹出一个或多个寄存器的值。基本语法如下：

```armasm
POP {reglist}
```

其中，reglist 是要从栈中弹出的寄存器列表。

示例：

```armasm
POP {R0-R3} ; 从栈中弹出值到寄存器 R0-R3
```

在这个示例中，POP 指令从栈中弹出值到寄存器 R0-R3。每次出栈操作时，**栈顶指针向高地址方向移动**。

以下是一个简单的示例，演示如何使用 PUSH 和 POP 指令保存和恢复寄存器状态：

```armasm
; 假设在调用一个函数前，需要保存 R0-R3 寄存器的值

PUSH {R0-R3} ; 将寄存器 R0-R3 的值推入栈中

; 调用函数
BL some_function

; 在函数返回后，恢复 R0-R3 寄存器的值
POP {R0-R3}
```

在这个示例中，我们首先使用 PUSH 指令将寄存器 R0-R3 的值保存到栈中，然后调用一个函数。在函数返回后，我们使用 POP 指令恢复 R0-R3 寄存器的值。这样，我们可以确保**在调用函数前后，寄存器的值不会被修改**。 

**BL指令记录返回地址（下一条指令的地址）到 R14(LR)里** 

**R13(SP)是堆栈指针**

在实际编程中，你可能需要根据具体需求使用 PUSH 和 POP 指令保存和恢复寄存器状态。通过多加练习和实践，你将更加熟练地掌握这些指令的使用。

现在让我们再看一个稍微复杂一点的例子，演示如何使用栈保存函数调用时的局部变量和返回地址：

假设我们有一个名为 `sum` 的函数，该函数计算两个整数的和。我们将使用 R0 和 R1 寄存器传递参数，将结果存储在 R0 寄存器中。在 `sum` 函数内部，我们将使用 R4 作为局部变量。

```armasm
; 调用 sum 函数的代码

MOV R0, #5  ; 第一个参数：5
MOV R1, #3  ; 第二个参数：3

BL sum  ; 调用 sum 函数

; 此时 R0寄存器中存储着两个数的和

; sum 函数的实现
sum:
; 保存寄存器状态
PUSH {R0-R3, R4, LR} ; 保存 R0-R3, R4 寄存器和返回地址（Link Register，LR）

; 计算两个数的和
MOV R4, R0 ; 将 R0 的值（第一个参数）复制到 R4 寄存器
ADD R0, R4, R1 ; 将 R4 和 R1 的值相加，并将结果存储在 R0 寄存器中

; 恢复寄存器状态
POP {R0-R3, R4, LR} ; 从栈中弹出值到 R0-R3, R4 寄存器和返回地址（Link Register，LR）

; 返回
BX LR ; 使用 BX 指令跳转到 LR 寄存器存储的返回地址
```

在这个例子中，我们首先使用 PUSH 指令保存寄存器 R0-R3、R4 和返回地址（Link Register，LR）。然后我们计算两个数的和，并将结果存储在 R0 寄存器中。最后，我们使用 POP 指令恢复寄存器状态，并使用 BX 指令跳转到 LR 寄存器存储的返回地址。

通过这个示例，你应该能更好地理解如何使用栈操作指令保存和恢复寄存器状态、局部变量和返回地址。在实际编程中，你可能需要根据具体需求使用这些指令。通过多加练习和实践，你将更加熟练地掌握这些指令的使用。