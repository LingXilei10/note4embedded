### 存储器映射

   存储器本身是不具有地址的，是一块具有特定功能的内存单元，它的地址是由芯片厂商或用户分配，**给存储器分配地址的过程就叫做存储区映射**。给内存单元分配地址之后，就可以通过指针去操作内存地址。

### 存储器映射表

   我们知道，GD32是一个32位的单片机，它的地址范围为2的32次方，也就是**4GB的地址空间**。为了降低不同客户在相同应用时的软件复杂度，存储映射是按Cortex-M4处理器提供的规则预先定义的。在存储器映射表中，**一部分地址空间由Arm Cortex-M4的系统外设所占用，且不可更改。其余部分地址空间可由芯片供应商定义使用**。

   关于存储映射表的内容，大家可以去查看用户手册的第38页。

### 1.1.3.什么是寄存器

   寄存器是具有特定功能的内存单元，通过操作这些内存单元可以驱动外设工作。寄存器按功能又可分为**指令寄存器、地址寄存器和数据寄存器**，处理器可以使用**相互独立的总线来读取指令和加载/存储数据**。

### 1.1.4.寄存器映射

   程序存储器，数据存储器，寄存器和I / O端口都在同一个线性的4 GB的地址空间之内。每一个寄存器都对应不同的功能，操作相应的寄存器就可以配置不同的功能。如果我们要控制某个外设工作，那我们可以找到这个单元的起始地址，然后通过c语言指针的方式来访问这些内存单元。但通常我们会**给这个特殊的内存单元取一个名字，这个给已经分配好地址的有特定功能的内存单元取别名的过程就叫寄存器映射**，这个别名就是我们所说的寄存器。

### 1.1.5.寄存器重映射

   **给寄存器再分配一个地址的过程叫做寄存器重映射**。

### 1.1.6.总线基地址

   片上外设区域分为三条总线，分别为AHB总线、APB1总线和APB2总线。AHB总线最高时钟可达200MHZ，APB1总线最高时钟可达50MHZ，APB2总线时钟最高可达100MHZ。根据外设速度的不同，不同的总线挂载着不同的外设。总线的最低地址我们称为该总线的基地址，总线基地址也是挂载在该总线上的首个外设的地址。关于总线上挂载的外设更多详细信息请查看数据手册的第11页。

   关于总线基地址和地址范围如表1-6-1所示。

| 总线名称 | 总线基地址  | 总线地址范围            |
| -------- | ----------- | ----------------------- |
| APB1     | 0x4000 0000 | 0x4000 0000-0x4000 FFFF |
| APB2     | 0x4001 0000 | 0x4001 0000-0x4001 FFFF |
| AHB1     | 0x4002 0000 | 0x4002 0000-0x4FFF FFFF |
| AHB2     | 0x5000 0000 | 0x5000 0000-0x5FFF FFFF |

表1-6-1

### 1.1.7.外设基地址

   每个总线上都挂载着很多外设，这些外设也都有自己的地址范围。

   关于GPIO这个外设的地址映射信息如表1-7-1所示。

| 外设名称 | 外设基地址  | 相对于AHB1总线的地址偏移 |
| -------- | ----------- | ------------------------ |
| GPIOA    | 0x4002 0000 | 0x0000 0000U             |
| GPIOB    | 0x4002 0400 | 0x0000 0400U             |
| GPIOC    | 0x4002 0800 | 0x0000 0800U             |
| GPIOD    | 0x4002 0C00 | 0x0000 0C00U             |
| GPIOE    | 0x4002 1000 | 0x0000 1000U             |
| GPIOF    | 0x4002 1400 | 0x0000 1400U             |
| GPIOG    | 0x4002 1800 | 0x0000 1800U             |
| GPIOH    | 0x4002 1C00 | 0x0000 1C00U             |
| GPIOI    | 0x4002 2000 | 0x0000 2000U             |

表1-7-1

### 1.1.8.外设寄存器地址

   在外设的地址范围内，分布着该外设的寄存器。

   以GPIO外设为例，GPIO外设地址范围内有很多个寄存器，每一个都有特定的功能，通过操作对应的寄存器来配置GPIO的功能。每个寄存器都为32位，占4个字节，这里我们以GPIOA端口的寄存器进行介绍。

   关于GPIOA端口寄存器地址映信息如表1-8-1所示。

| 寄存器名称   | 地址偏移 | 相对于GPIOA的地址  |
| ------------ | -------- | ------------------ |
| GPIOx_CTL    | 0x00     | GPIOA_BASE + 0x00U |
| GPIOx_OMODE  | 0x04     | GPIOA_BASE + 0x04U |
| GPIOx_OSPD   | 0x08     | GPIOA_BASE + 0x08U |
| GPIOx_PUD    | 0x0C     | GPIOA_BASE + 0x0CU |
| GPIOx_ISTAT  | 0x10     | GPIOA_BASE + 0x10U |
| GPIOx_OCTL   | 0x14     | GPIOA_BASE + 0x14U |
| GPIOx_BOP    | 0x18     | GPIOA_BASE + 0x18U |
| GPIOx_LOCK   | 0x1C     | GPIOA_BASE + 0x1CU |
| GPIOx_AFSEL0 | 0x20     | GPIOA_BASE + 0x20U |
| GPIOx_AFSEL1 | 0x24     | GPIOA_BASE + 0x24U |
| GPIOx_BC     | 0x28     | GPIOA_BASE + 0x28U |
| GPIOx_TG     | 0x2C     | GPIOA_BASE + 0x2CU |

表1-8-1

### 1.1.9.如何操作寄存器

   上面我们了解到了寄存器映射和GPIO外设寄存器的相关地址，那我们怎么去编写代码操作寄存器呢？下面我们就来简单介绍一下。

   比如我们想让GPIOA端口的16个引脚都置1。我们需要去**配置端口输出寄存器GPIOx_OCTL**，通过查找用户手册177页可以知道这个寄存器的地址偏移量为0x14，GPIOA端口的基地址为0x4002 0000，所以GPIOA_OCTL寄存器的地址为0x4002 0000 + 0x14 = 0x4002 0014,那我们就是对这个地址进行操作。那如何操作呢？

   关于端口位操作寄存器说明如图1-9-1所示。

![img](https://lceda001.feishu.cn/space/api/box/stream/download/asynccode/?code=NzdhODJiYmI1MWYyZWU4MjNhNmVhZDk4MmQ0NzU2MWJfZ3YyYUJYd3llM1dqZnNQRDFpSkJkWDZ5RlZEMjFEMGtfVG9rZW46VDU4WmJGWkp3b29STGN4bkF6MGNxN1VibkNmXzE3NDM0Mzg2NjY6MTc0MzQ0MjI2Nl9WNA)

图1-9-1

   通过图1-9-1可以了解到要想使能所有引脚配置为1,只需要将OCTLy（y=0..15）对应的位置1即可。也就是配置GPIOA_OCTL寄存器的高16位为0，低16位为1,换成十六进制就是0x0000FFFF。

1. **通过绝对地址访问内存单元**

```Plaintext
/* GPIOA 端口的16个引脚全部输出高电平 */

*(unsigned int*)(0x40020014) = 0xFFFF;
```

说明：

`(unsigned int*) `的作用是将0x40020014这个数字量 强制类型转化为 **无符号整形的 地址，告诉编译器这是一个地址**。

`*(unsigned int)`**是相当于控制地址里的内容**，也就是对这个地址对应的内存空间的值，

`*(unsigned int*)(0x40020014) = 0xFFFF;`就是相当于对0x40020014这个内存空间赋值为0xFFFF。

2. **通过别名访问内存单元**

   通过上面的方式确实可以对寄存器地址进行操作，但是操作起来很麻烦，用户也不能清晰的明白这个地址对应的功能。如果我们**给每个地址都起一个名字**，这样看到名字是不是就知道这个地址对应什么功能了呢。

```Plaintext
/* GPIOA 端口的16个引脚全部输出高电平 */

#define GPIOA_OCTL  (unsigned int*)(0x40020014)

*GPIOA_OCTL = 0xFFFF;
```

   或者为了方便我们干脆将*和地址写到一个，如下。

```Plaintext
/* GPIOA 端口的16个引脚全部输出高电平 */

#define GPIOA_OCTL *(unsigned int*)(0x40020014)

GPIOA_OCTL = 0xFFFF;
```