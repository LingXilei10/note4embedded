# SPI驱动屏幕显示文字与图片

##  屏幕初始化

这段代码实现了一个基于SPI接口的LCD显示驱动功能。我来分段解释：

1. **SPI读写函数**：

```c
uint8_t Spi4_Read(void) {
    while (RESET == spi_i2s_flag_get(SPI4, SPI_FLAG_RBNE)); // 等待接收缓冲区非空
    return spi_i2s_data_receive(SPI4); // 读取SPI数据
    // 注意：这里有一个无用的while循环（永远不会执行）
}

void Spi4_Write(uint8_t dat) {
    while (RESET == spi_i2s_flag_get(SPI4, SPI_FLAG_TBE)); // 等待发送缓冲区空
    spi_i2s_data_transmit(SPI4, dat); // 发送数据
    while (RESET == spi_i2s_flag_get(SPI4, SPI_FLAG_TBE)); // 等待发送完成
}
```

1. **宏定义**：

```c
#define Lcd_SpiRead  Spi4_Read
#define Lcd_SpiWrite Spi4_Write
```

将SPI函数重命名为LCD专用名称。

1. **LCD写操作**：

```c
void LCD_Writ_Bus(uint8_t dat) {    
    LCD_CS_L; // 片选拉低（开始通信）
    Lcd_SpiWrite(dat); // 发送数据
    delay(4); // 短暂延时
    LCD_CS_H; // 片选拉高（结束通信）
}
```

1. **数据写入函数**：

```c
void Lcd_WriteData(uint8_t data) {
    LCD_Writ_Bus(data); // 写入8位数据
}

void Lcd_WriteData16(uint16_t data) {
    LCD_Writ_Bus(data >> 8); // 先写高字节
    LCD_Writ_Bus(data);      // 再写低字节
}
```

注意：

1. `Spi4_Read()`中有一个永远不会执行的冗余while循环（在return语句之后）
2. 代码使用了硬件SPI（SPI4）进行通信
3. 每次传输都通过CS（片选）信号控制通信开始/结束
4. 16位数据被拆分为两个8位传输（大端序）

典型使用场景：驱动SPI接口的LCD屏幕，发送命令或像素数据。

## 字符取模

这段代码定义了两个**字模数组**，分别用于存储**ASCII字符（12x6像素）**和**中文字符（16x16像素）**的点阵数据，主要用于在LCD或OLED屏幕上显示文字。以下是详细解释：

------

### 1. **ASCII字符字模（12x6像素）**

```c
const unsigned char ascii_1206[][12] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, /*" ",0*/
    {0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x04,0x00,0x00}, /*"!",1*/
    // ... 其他ASCII字符
};
```

- **结构**：二维数组，每个字符占12字节（每字节8位，共12x8=96位，实际有效宽度为12x6=72位，可能有未使用的位）。

- 用途

  ：存储ASCII字符的点阵数据，例如：

  - `" "`（空格）全为0，表示空白。
  - `"!"`（感叹号）的像素点阵如注释所示。

- **显示方式**：每个字节的每一位（bit）对应一个像素点（1点亮，0熄灭）。

------

### 2. **中文字符字模（16x16像素）**

```c
typedef struct {
    unsigned char Index[2];  // 存储汉字（如"始"的GB2312编码）
    unsigned char Msk[32];   // 16x16点阵数据（32字节）
} typFNT_GB16;

const typFNT_GB16 tfont16[] = {
    {"始",  // 汉字
     0x08,0x04,0x08,0x04,0x08,0x04,0x08,0x02, // 前16字节（上半部分）
     0x3F,0x12,0x24,0x21,0xA4,0x7F,0x24,0x41, // 后16字节（下半部分）
     // ... 其他数据
    }, /*"始",0*/
    {"开", 
     0x00,0x00,0xFE,0x3F,0x10,0x04,0x10,0x04, // 上半部分
     // ... 其他数据
    }, /*"开",0*/
    // ... 其他汉字
};
```

- 结构

  ：

  - `Index[2]`：存储汉字的GB2312编码（如"始"的编码）。
  - `Msk[32]`：16x16点阵数据（共32字节，每字节8位，16行x16列）。

- 显示原理

  ：

  - 每个汉字由32字节描述，每2字节（16位）对应一行像素（高位在前）。
  - 例如：`0x08,0x04`表示第一行的二进制`00001000 00000100`，从左到右点亮对应像素。

------

### 3. **代码用途**

- **ASCII字符**：用于显示英文、数字和符号（如`!`、`#`、`%`等）。
- **中文字符**：用于显示汉字（如"始"、"开"、"游戏"等）。
- **配合LCD驱动**：通过`Lcd_WriteData`等函数将点阵数据发送到屏幕，逐像素绘制字符。

------

### 4. **注意事项**

1. 字模格式

   ：

   - ASCII字模宽度可能是6像素（但存储为12字节，可能有冗余）。
   - 汉字字模是标准的16x16像素，符合GB2312编码。

2. 注释说明

   ：

   - 注释中的`/*"始",0*/`表示字符和其在数组中的索引。

3. 未使用的数据

   ：

   - 汉字"开"的注释中有两套数据，实际使用第二套（第一套被注释）。

------

### 5. **示例：显示汉字"始"**

1. 从`tfont16`数组中找到`"始"`的字模数据。

2. 逐字节发送

   ```
   Msk[32]
   ```

   到LCD，按位解析像素：

   - 例如`0x08`（二进制`00001000`）表示第4个像素点亮。

3. 最终在屏幕上显示16x16的汉字。

------

这种字模方案常见于嵌入式显示系统（如ST7789、SSD1306驱动的屏幕）。如果需要扩展字符集，需按相同格式添加更多字模数据。



## 图片取模

这段代码是一个用于在LCD屏幕上显示图片的函数，采用**16位色（RGB565格式）**逐像素绘制。以下是详细解析：

------

### **函数功能**

```c
void LCD_ShowPicture(uint16_t x, uint16_t y, uint16_t length, uint16_t width, const uint8_t pic[])
```

- **作用**：在LCD屏幕的指定位置（`x`,`y`）绘制一张图片。

- 参数

  ：

  - `x`, `y`：图片左上角的起始坐标。
  - `length`：图片的**水平方向像素数**（宽度）。
  - `width`：图片的**垂直方向像素数**（高度）。
  - `pic[]`：存储图片数据的数组，每个像素占2字节（RGB565格式）。

------

### **关键步骤解析**

1. **设置显示区域**

   ```c
   Lcd_PushStart(x, y, x+length-1, y+width-1);
   ```

   - 调用`Lcd_PushStart`设置LCD的显示区域（从`(x,y)`到`(x+length-1, y+width-1)`），告诉屏幕后续数据将填充这个矩形区域。

2. **逐像素写入数据**

   ```c
   for(i=0; i<length; i++) {
       for(j=0; j<width; j++) {
           Lcd_WriteData(pic[k*2]);     // 写入高字节（R+G高位）
           Lcd_WriteData(pic[k*2+1]);   // 写入低字节（G低位+B）
           k++;
       }
   }
   ```

   - **双重循环**：遍历每个像素点（`i`为列，`j`为行）。

   - RGB565格式

     ：

     每个像素由2字节（16位）组成，按**大端序存储**：

     - `pic[k*2]`：高字节（红色5位 + 绿色高3位）。
     - `pic[k*2+1]`：低字节（绿色低3位 + 蓝色5位）。

   - **写入顺序**：**先高字节后低字节，符合LCD驱动要求**。

------

### **关键细节**

1. **颜色格式**

   - RGB565是一种16位色格式，分解如下：

     ```
     RRRRR GGGGGG BBBBB
     ↑高字节   ↑低字节
     ```

   - 例如：红色（0xF800）对应`pic[k*2]=0xF8`, `pic[k*2+1]=0x00`。

2. **数据存储顺序**

   - 数组`pic[]`的像素按**行优先顺序**排列（从左到右、从上到下）。

3. **性能优化**

   - 函数通过`Lcd_PushStart`一次性设置显示区域，避免每像素都发送坐标指令，提升传输效率。

------

### **使用示例**

假设要在坐标`(10,20)`处显示一张100x50的图片：

```c
const uint8_t my_pic[] = {0xF8, 0x00, 0x07, 0xE0, ...}; // RGB565数据
LCD_ShowPicture(10, 20, 100, 50, my_pic);
```

- 图片数据`my_pic`的大小应为：`100 * 50 * 2 = 10,000字节`。

------

### **注意事项**

1. **边界检查**
   - 需确保`x+length`和`y+width`不超过LCD分辨率，否则会显示错乱。
2. **数据对齐**
   - 输入数组`pic[]`必须严格按RGB565格式排列，否则颜色异常。
3. **硬件依赖**
   - `Lcd_PushStart`和`Lcd_WriteData`需与具体LCD驱动芯片（如ST7789、ILI9341）兼容。

------

### **总结**

这段代码是一个高效的LCD图片显示函数，适用于嵌入式系统（如STM32）。其核心是通过行列循环和RGB565数据流，将像素逐个写入LCD的指定区域。

## 功能演示

这段代码是一个基于嵌入式系统（如STM32）的**主程序**，主要功能是初始化硬件并在**SPI接口的LCD屏幕**上显示图形和文字界面。以下是逐步解析：

------

### **1. 硬件初始化**

```c
nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);  // 设置中断优先级分组（2位抢占优先级，2位子优先级）
systick_config();                                  // 初始化系统滴答定时器（用于延时函数）
led_gpio_config();                                 // 初始化LED灯（用于调试指示）
key_gpio_config();                                 // 初始化按键（检测用户输入）
usart_gpio_config(115200U);                        // 初始化串口0（波特率115200，用于调试输出）
Lcd_Init();                                       // 初始化SPI LCD屏幕
```

- **作用**：配置MCU的时钟、外设和中断，确保后续LCD操作能正常运行。

------

### **2. LCD界面绘制**

```c
LCD_Fill(0, 0, LCD_W, LCD_H, COLOR_BLUE);         // 全屏填充深蓝色背景
LCD_ShowPicture((LCD_W-222)/2, 0, 222, 60, gImage_lCKFB); // 居中显示一张222x60的图片
LCD_DrawRectangle(10, 70, LCD_W-10, LCD_H-10, COLOR_BLACK); // 绘制黑色边框矩形
```

- 关键点

  ：

  - `gImage_lCKFB`是预先存储的图片数据（RGB565格式）。
  - 矩形框作为UI的边界，坐标从`(10,70)`到`(LCD_W-10, LCD_H-10)`。

------

### **3. 文字显示**

```c
// 显示不同大小的汉字"开始游戏"（白字蓝底）
LCD_ShowChinese(15, 85, "开始游戏", COLOR_WHITE, COLOR_BLUE, 12, 0);  // 12像素高
LCD_ShowChinese(15, 97, "开始游戏", COLOR_WHITE, COLOR_BLUE, 16, 0);  // 16像素高
LCD_ShowChinese(15, 113, "开始游戏", COLOR_WHITE, COLOR_BLUE, 24, 0); // 24像素高
LCD_ShowChinese(15, 137, "开始游戏", COLOR_WHITE, COLOR_BLUE, 32, 0); // 32像素高

// 显示不同大小的英文/数字"123abc"（白字蓝底）
LCD_ShowString(15, 169, "123abc", COLOR_WHITE, COLOR_BLUE, 16, 0);  // 16像素高
LCD_ShowString(15, 185, "123abc", COLOR_WHITE, COLOR_BLUE, 24, 0);  // 24像素高
LCD_ShowString(15, 209, "123abc", COLOR_WHITE, COLOR_BLUE, 32, 0);  // 32像素高
```

- 参数说明

  ：

  - `(x, y)`：文字起始坐标。
  - `COLOR_WHITE, COLOR_BLUE`：前景色（文字）和背景色。
  - `12/16/24/32`：字体高度（像素）。
  - `0`：可能表示字库索引或对齐方式。

------

### **4. 主循环**

```c
while(1); // 进入死循环，保持界面显示
```

- **作用**：防止程序退出，维持当前界面状态。实际项目中通常会在此处添加按键检测或动态更新逻辑。

------

### **关键细节**

1. **坐标计算**：
   - 文字和图形的位置通过垂直累加（如`60+10+5+12...`）实现简单排版。
   - 图片居中显示：`(LCD_W-222)/2`。
2. **字库支持**：
   - `LCD_ShowChinese`需依赖中文字库（如GB2312点阵数组）。
   - `LCD_ShowString`可能使用ASCII字库或内置英文字体。
3. **颜色定义**：
   - `COLOR_BLUE`等应为预定义的RGB565颜色值（如`0x001F`对应蓝色）。

------

### **典型应用场景**

- 嵌入式设备的启动界面（如智能家居控制面板、游戏机菜单）。
- 需要展示多尺寸文字和图片的嵌入式UI。

------

### **优化建议**

1. **动态内容**：在`while(1)`中添加按键扫描或传感器数据更新。
2. **错误处理**：检查`Lcd_Init()`是否成功。
3. **代码可读性**：用宏或变量替代硬编码的坐标（如`#define TITLE_Y 60`）。

如果需要更详细的实现（如字库如何工作或图片数据格式），可以进一步探讨！

